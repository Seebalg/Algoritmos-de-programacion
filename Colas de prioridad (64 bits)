#define myPositiveInfinite 9223372036854775807
#define myNegativeInfinite -9223372036854775807

int  Parent(int i) {
    return i / 2; /* i >> 1; */
}

int Left(int i) {
    return 2 * i; /* i << 1; */
}

int Right(int i) {
    return 2 *i + 1;  /* (i << 1) + 1; */
}

void MinHeapify(long long int Q[], int i, int heapSize) {
    int l, r, least;
    long long int temp;
    l = Left(i);
    r = Right(i);
    if((l <= heapSize) && (Q[l] < Q[i]))
        least = l;
    else
        least = i;

    if((r <= heapSize) && (Q[r] < Q[least]))
        least = r;

    if(least != i) {
        temp = Q[i];
        Q[i] = Q[least];
        Q[least] = temp;
        MinHeapify(Q, least, heapSize);
    }
}

long long int MinPQ_Minimum(long long int Q[]) {
    return Q[1];
}

long long int MinPQ_Extract(long long int Q[], int *heapSize) {
    long long int min = myNegativeInfinite;
    if(*heapSize < 1)
        printf("Heap Uderflow.\n");
    else {
        min = Q[1];
        Q[1] = Q[*heapSize];
        *heapSize = *heapSize - 1;
        MinHeapify(Q, 1, *heapSize);
    }
    return min;
}

void MinPQ_DecreaseKey(long long int Q[], int i, long long int key) {
    long long int temp;

    if(key > Q[i])
        printf("New key is higher tan current key");

    else {
        Q[i] = key;
        while((i > 1) && (Q[Parent(i)] > Q[i])) {
            temp = Q[i];
            Q[i] = Q[Parent(i)];
            Q[Parent(i)] = temp;
            i = Parent(i);
        }
    }
}

void MinPQ_Insert(long long int Q[], long long int key, int *heapSize) {
    *heapSize = *heapSize + 1;
    Q[*heapSize] = myPositiveInfinite;
    MinPQ_DecreaseKey(Q, *heapSize, key);
}
